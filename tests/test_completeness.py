"""Tests for transcript completeness validation.

Tests the word-count comparison logic that detects when an LLM
silently truncates a long transcript.
"""

from api.services.completeness import (
    CompletenessResult,
    check_completeness,
    count_content_words,
    count_source_words,
)

# ---------------------------------------------------------------------------
# Fixtures / helpers
# ---------------------------------------------------------------------------


def _words(n: int) -> str:
    """Generate a string with exactly n words."""
    return " ".join(f"word{i}" for i in range(n))


def _srt_block(index: int, text: str) -> str:
    """Generate a single SRT subtitle block with valid timecodes."""
    mm = index // 60
    ss = index % 60
    return f"{index}\n" f"00:{mm:02d}:{ss:02d},000 --> 00:{mm:02d}:{ss:02d},500\n" f"{text}\n\n"


def _srt_file(blocks: int, words_per_block: int = 10) -> str:
    """Generate an SRT file with the given number of blocks."""
    parts = []
    for i in range(1, blocks + 1):
        text = " ".join(f"word{i}_{j}" for j in range(words_per_block))
        parts.append(_srt_block(i, text))
    return "".join(parts)


def _formatter_output(body: str) -> str:
    """Wrap body text in a realistic formatter output with metadata."""
    return (
        "<!-- Provenance: Generated by ai-editorial-assistant-v3 -->\n\n"
        "**Project:** TEST123\n"
        "**Program:** Test Show\n\n"
        "---\n\n"
        f"{body}\n\n"
        "**Status:** ready_for_editing\n"
    )


# ---------------------------------------------------------------------------
# count_content_words
# ---------------------------------------------------------------------------


class TestCountContentWords:
    def test_plain_text(self):
        assert count_content_words("hello world foo bar") == 4

    def test_strips_html_comments(self):
        text = "<!-- This is a comment --> actual words here"
        assert count_content_words(text) == 3

    def test_strips_multiline_html_comments(self):
        text = "<!-- \nReview notes:\n- Fix speaker name\n-->\nactual content here"
        assert count_content_words(text) == 3

    def test_strips_bold_markers(self):
        text = "**John Smith:** Hello there"
        # Strips the **, leaves words: John Smith: Hello there
        assert count_content_words(text) == 4

    def test_strips_heading_markers(self):
        text = "# Title\n## Subtitle\nBody text"
        # Strips #/##, leaves: Title Subtitle Body text
        assert count_content_words(text) == 4

    def test_strips_header_before_separator(self):
        text = "header metadata here\n---\nactual content after"
        assert count_content_words(text) == 3  # "actual content after"

    def test_strips_metadata_header_block(self):
        text = "**Project:** TEST123\n**Program:** My Show\n---\nactual transcript words"
        assert count_content_words(text) == 3

    def test_no_separator_keeps_all_text(self):
        text = "all words are kept without separator"
        assert count_content_words(text) == 6

    def test_realistic_formatter_output(self):
        body = "John Smith said hello to the audience. " * 10  # 70 words
        output = _formatter_output(body)
        count = count_content_words(output)
        # Should count body words, not metadata/provenance
        assert count >= 60  # Body dominates; metadata stripped


# ---------------------------------------------------------------------------
# count_source_words
# ---------------------------------------------------------------------------


class TestCountSourceWords:
    def test_plain_text(self):
        assert count_source_words("one two three", is_srt=False) == 3

    def test_srt_strips_indices(self):
        srt = "1\n00:00:01,000 --> 00:00:02,000\nhello world\n\n"
        count = count_source_words(srt, is_srt=True)
        assert count == 2  # Just "hello world"

    def test_srt_strips_timecodes(self):
        srt = _srt_file(blocks=3, words_per_block=5)
        count = count_source_words(srt, is_srt=True)
        assert count == 15  # 3 blocks * 5 words

    def test_srt_multi_block(self):
        srt = _srt_file(blocks=5, words_per_block=8)
        count = count_source_words(srt, is_srt=True)
        assert count == 40

    def test_non_srt_no_stripping(self):
        text = "1\n00:00:01,000 --> 00:00:02,000\nhello world"
        count = count_source_words(text, is_srt=False)
        # Without SRT stripping, the timecode and index are counted as words
        assert count > 2


# ---------------------------------------------------------------------------
# check_completeness — core logic
# ---------------------------------------------------------------------------


class TestCheckCompleteness:
    def test_complete_transcript(self):
        """Output covering 90% of source should pass."""
        source = _words(1000)
        output = _formatter_output(_words(900))
        result = check_completeness(output, source)
        assert result.is_complete is True
        assert result.skipped is False
        assert result.coverage_ratio >= 0.7

    def test_truncated_transcript(self):
        """Output covering only 40% should fail."""
        source = _words(1000)
        output = _formatter_output(_words(400))
        result = check_completeness(output, source)
        assert result.is_complete is False
        assert result.skipped is False
        assert "TRUNCATION DETECTED" in result.reason

    def test_borderline_at_threshold(self):
        """Output at exactly 70% should pass (>=)."""
        source = _words(1000)
        output = _words(700)  # No wrapper to control count precisely
        result = check_completeness(output, source)
        assert result.is_complete is True

    def test_just_below_threshold(self):
        """Output just under 70% should fail."""
        source = _words(1000)
        output = _words(690)
        result = check_completeness(output, source)
        assert result.is_complete is False

    def test_short_transcript_skipped(self):
        """Transcripts under min_source_words are skipped."""
        source = _words(200)
        output = _words(50)  # Would be 25% — but should be skipped
        result = check_completeness(output, source)
        assert result.is_complete is True
        assert result.skipped is True
        assert "Skipped" in result.reason

    def test_custom_threshold(self):
        """Custom threshold overrides default."""
        source = _words(1000)
        output = _words(850)
        # With 90% threshold, 85% coverage should fail
        result = check_completeness(output, source, threshold=0.90)
        assert result.is_complete is False
        # With 50% threshold, should pass
        result = check_completeness(output, source, threshold=0.50)
        assert result.is_complete is True

    def test_custom_min_source_words(self):
        """Custom min_source_words overrides default."""
        source = _words(300)
        output = _words(100)
        # Default min is 500, so 300-word source is skipped
        result = check_completeness(output, source)
        assert result.skipped is True
        # With lower min, check should run and fail
        result = check_completeness(output, source, min_source_words=100)
        assert result.skipped is False
        assert result.is_complete is False

    def test_pre_computed_source_word_count(self):
        """Pre-computed source word count overrides internal counting."""
        source = "this will not be counted"
        output = _words(800)
        # Force source_word_count=1000 regardless of actual source text
        result = check_completeness(output, source, source_word_count=1000)
        assert result.source_word_count == 1000
        assert result.is_complete is True  # 800/1000 = 80% > 70%

    def test_duration_in_reason(self):
        """Duration is included in truncation reason when provided."""
        source = _words(1000)
        output = _words(300)
        result = check_completeness(output, source, duration_minutes=45.5)
        assert result.is_complete is False
        assert "45.5 minutes" in result.reason

    def test_duration_not_in_pass_reason(self):
        """Duration is NOT included when check passes."""
        source = _words(1000)
        output = _words(900)
        result = check_completeness(output, source, duration_minutes=30.0)
        assert result.is_complete is True
        assert "minutes" not in result.reason


# ---------------------------------------------------------------------------
# check_completeness — SRT integration
# ---------------------------------------------------------------------------


class TestCheckCompletenessSRT:
    def test_srt_source_stripping(self):
        """SRT indices and timecodes should not inflate source word count."""
        # 50 blocks * 10 words = 500 dialogue words
        srt_source = _srt_file(blocks=50, words_per_block=10)
        # Output has 400 words — 80% of dialogue content
        output = _words(400)
        result = check_completeness(output, srt_source, is_srt=True)
        assert result.source_word_count == 500
        assert result.is_complete is True  # 400/500 = 80%

    def test_srt_truncation_detected(self):
        """Truncation caught even with SRT formatting stripped."""
        srt_source = _srt_file(blocks=100, words_per_block=10)  # 1000 words
        output = _words(300)  # Only 30% coverage
        result = check_completeness(output, srt_source, is_srt=True)
        assert result.is_complete is False
        assert result.source_word_count == 1000


# ---------------------------------------------------------------------------
# CompletenessResult.to_dict
# ---------------------------------------------------------------------------


class TestCompletenessResultToDict:
    def test_all_fields_present(self):
        result = CompletenessResult(
            is_complete=True,
            source_word_count=1000,
            output_word_count=850,
            coverage_ratio=0.85,
            threshold=0.70,
            reason="Coverage 85.0% meets threshold 70%",
        )
        d = result.to_dict()
        assert d["is_complete"] is True
        assert d["source_word_count"] == 1000
        assert d["output_word_count"] == 850
        assert d["coverage_ratio"] == 0.85
        assert d["threshold"] == 0.70
        assert d["skipped"] is False  # default

    def test_coverage_ratio_rounded(self):
        """Coverage ratio should be rounded to 3 decimal places."""
        result = CompletenessResult(
            is_complete=True,
            source_word_count=1000,
            output_word_count=777,
            coverage_ratio=0.777777,
            threshold=0.70,
            reason="test",
        )
        assert result.to_dict()["coverage_ratio"] == 0.778

    def test_skipped_flag(self):
        result = CompletenessResult(
            is_complete=True,
            source_word_count=200,
            output_word_count=0,
            coverage_ratio=1.0,
            threshold=0.70,
            reason="Skipped",
            skipped=True,
        )
        assert result.to_dict()["skipped"] is True


# ---------------------------------------------------------------------------
# Edge cases
# ---------------------------------------------------------------------------


class TestEdgeCases:
    def test_empty_source(self):
        """Empty source should be skipped (0 words < 500)."""
        result = check_completeness("some output", "")
        assert result.skipped is True

    def test_empty_output(self):
        """Empty output against real source should fail."""
        source = _words(1000)
        result = check_completeness("", source)
        assert result.is_complete is False
        assert result.output_word_count == 0

    def test_output_longer_than_source(self):
        """Output with more words than source (edge case) should pass."""
        source = _words(600)
        output = _words(800)  # 133% coverage
        result = check_completeness(output, source)
        assert result.is_complete is True
        assert result.coverage_ratio > 1.0
